/* 
 * A program to test the efficiency
 * of various probing methods to
 * generate keys for hash tables
 */

#include <iostream>
#include <iomanip>
#include <cstdlib>
#include <ctime>

using std::cin;
using std::cout;
using std::endl;
using std::setprecision;

// The size of the hash table
// This really should be a prime but  I will just shutup and do as I'm told
const int N = 1999;

// The desired load factor of the table
const double ALPHA = 0.5;

// The number of trials to do in each experiment
const int NUM_TRIALS = 100;

// A constant to denote that the index is empty
const int VACANT = -1;

// A constant to determine the pace at 
// which linear probing will advance positions
const int LINEAR_STEP = 1;

// The amount to left shift the randomly generated number
const int RANDOM_SHIFT = 15;

// Sets all the positions to vacant
void clear_hashtable(int T[]);

// Inserts n randomly generated keys into the table
// using the specified probing method TRIALS times
// postcondition: returns the number of comparisons made
int insert_hashtable(int T[], int n, bool isLinear);

// Fills the hashtable T with n values with the specified
// probing, generated by the getKey method TRIALS times
// postcondition: returns the average number of comparisons per insertion
double fill_experiment(int T[], int n, bool isLinear);

// Searches the hashtable T with values that are in the hash table
// postcondition: returns the average number of comparisons of the search
double successfull_search_experiment(int T[], int n, bool isLinear);

// Searches the hashtable T with values that are not in the hash table
// postcondition: returns the average number of comparisons of the search
double unsuccessfull_search_experiment(int T[], int n, bool isLinear);

// The hashing function; 0 < h(x) < N
int h(int x);

// This method will return a random number between 0 and 2^30
// when used with the GCC compiler. This method will not guarantee
// that the number is in the above range for any other compilers
int getKey();

// Searches for the item x in the hashtable T by using
// the specified probing method passed as a boolean
// postcondition: found is set to true if x is in T, and false otherwise
// postcondition: returns the number of comparisons made
int search_hashtable(int x, int T[], bool &found, bool isLinear);

// Inserts x into the hashtable T by using
// the specified probing method passed as a boolean
// precondition: the number of elements inserted < N
// postcondition: returns the number of comparisons made
int insert_hashtable(int x, int T[], bool isLinear);

int main()
{
   srand(time(nullptr));
   int TL[N], TQ[N];
   int n = N * ALPHA;
   
   cout << setprecision(3);
   cout << "*** Probe Tester by Gabriel Henderson ***" << endl;
   cout << "There will be " << n << " elements inserted" << endl;
   cout << "The designated load factor is: " << ALPHA << endl;
   
   cout << "The number of trials is: " << NUM_TRIALS << endl;
   cout << "Average comparisons per: \tLinear \t\tQuadratic" << endl;
   
   cout << "- Inserting 1000 keys \t\t" << fill_experiment(TL, n, true);
   cout << "\t\t" << fill_experiment(TQ, n, false) << endl;
   
   cout << "- Searching 1000 successful \t" << successfull_search_experiment(TL, n, true);
   cout << "\t\t" << successfull_search_experiment(TQ, n, false) << endl;
   
   cout << "- Searching 1000 unsuccessful \t" << unsuccessfull_search_experiment(TL, n, true);
   cout << "\t\t" << unsuccessfull_search_experiment(TQ, n, false) << endl;
   
	return 0;
}

double fill_experiment(int T[], int n, bool isLinear)
{
   int comparisons = 0;
   for(int t = 0; t < NUM_TRIALS; t++)
   {
      comparisons += insert_hashtable(T, n, isLinear);
   }
   
   return ((1.0 * comparisons) / n) / NUM_TRIALS;
}

double successfull_search_experiment(int T[], int n, bool isLinear)
{
   int comparisons = 0;
   for(int t = 0; t < NUM_TRIALS; t++)
   {
      insert_hashtable(T, n, isLinear);
      // look through all the already inserted values
      // and search for them again, there are only n of them
      for(int i = 0; i < N; i++)
      {
         bool garbage = false;
         if(T[i] != VACANT)
         {
            comparisons += search_hashtable(T[i], T, garbage, isLinear);
         }
      }
   }
   
   return ((1.0 * comparisons) / n) / NUM_TRIALS;
}

double unsuccessfull_search_experiment(int T[], int n, bool isLinear)
{
   int comparisons = 0;
   for(int t = 0; t < NUM_TRIALS; t++)
   {
      insert_hashtable(T, n, isLinear);
      for(int i = 0; i < n; )
      {
         int temp = 0;
         bool found = false;
         temp = search_hashtable(getKey(), T, found, isLinear);
 
         if(!found)
         {
            comparisons += temp;
            i++;
         }
      }
   }
   
   return ((1.0 * comparisons) / n) / NUM_TRIALS;
}

void clear_hashtable(int T[])
{
   for(int i = 0; i < N; i++)
   {
      T[i] = VACANT;
   }
}

int insert_hashtable(int T[], int n, bool isLinear)
{
   clear_hashtable(T);
   int comparisons = 0;
   
   for(int i = 0; i < n; i++)
   {
      comparisons += insert_hashtable(getKey(), T, isLinear);
   }
   
   return comparisons;
}

int h(int x)
{
   return x % N;
}

int getKey()
{
   // Use bit shifting and bitwise OR for increased efficiency
   // In GCC, 0 <= rand(x) < 2^15, so bit shift by 15 once so that
   // 0 <= getKey(x) < 2^30
   return ((rand() << RANDOM_SHIFT) | rand());
}

int search_hashtable(int x, int T[], bool &found, bool isLinear)
{
   int comparisons = 0;
   int hash = h(x);
   found = false;
   
   if(T[hash] == VACANT)
   {
      // account for the one comparison made if the loop doesn't start
      comparisons = 1;
   }
   
   int i = 1;
   while(T[hash] != VACANT && !found)
   {
      if(T[hash] == x)
      {
         found = true;
      }
      
      if(isLinear)
      {
         hash = h(hash + LINEAR_STEP);
      }
      
      else
      {
         hash = h(hash + (i * i));
      }
      
      ++i;
      ++comparisons;
   }
   
   return comparisons;
}

int insert_hashtable(int x, int T[], bool isLinear)
{
   bool present = false;
   int comparisons = 0;
   
   // This is just to make sure the values are unique
   // we will not add these comparisons to our count
   search_hashtable(x, T, present, isLinear);
   
   if(!present)
   {
      int hash = h(x);
   
      int i = 1;
      while(T[hash] != VACANT)
      {
         if(isLinear)
         {
            hash = h(hash + LINEAR_STEP);
         }
         
         else
         {
            hash = h(hash + (i * i));
         }
         ++i;
         ++comparisons;
      }
      
      T[hash] = x;
   }
   
   return comparisons;
}
